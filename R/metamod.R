#' linear regression metamodeling
#'
#' @param analysis either "oneway" or "twoway"
#' @param psa psa object
#' @param parms String with the name of the parameter of interest
#' @param strategies vector of strategies to consider. the default (NULL) is that all strategies are considered. The
#' @param outcome either effectiveness ("eff"), cost, net health benefit ("nhb"), or net monetary benefit ("nmb")
#' @param wtp if outcome is NHB or NMB, must provide the willingness-to-pay threshold
#' @param type type of metamodel
#' @param poly.order Order of polynomial for the linear regression metamodel.
#' Default: 2
#'
#' @importFrom stats as.formula formula getCall lm
#' @export
metamod <- function(analysis = c("oneway", "twoway"),
                    psa, parms = NULL, strategies = NULL,
                    outcome = c("eff", "cost", "nhb", "nmb"),
                    wtp = NULL,
                    type = "poly", poly.order = 2) {
  # get parameter names
  pnames <- psa$parnames

  # analysis
  analysis <- match.arg(analysis)

  # make sure all of parms is in parameter names
  if (is.null(parms)) {
    parms <- pnames
  } else if (!all(parms %in% pnames)) {
    wrong_p <- setdiff(p, pnames)
    stop(paste0("the following parameters are not valid: ",
                paste(wrong_p, collapse = ",")))
  } else if (length(parms) != 2 & analysis == "twoway") {
    stop("If analysis == twoway, exactly 2 parms must be provided.")
  }

  # define dependent variables
  outcome <- match.arg(outcome)

  ## make sure wtp is not null if nmb or nhb
  if (is.null(wtp) & (outcome == "nmb" | outcome == "nhb")) {
    stop("wtp must be provided if nmb or nhb is the outcome to be modeled")
  }

  # define y, the outcome matrix
  if (outcome == "eff") {
    y <- psa$effectiveness
  }
  if (outcome == "cost") {
    y <- psa$cost
  }
  if (outcome == "nhb") {
    y <- psa$effectiveness - psa$cost / wtp
  }
  if (outcome == "nmb") {
    y <- psa$effectiveness * wtp - psa$cost
  }

  # define strategies
  strat <- psa$strategies

  ## make sure all subset strats are in strat
  if (is.null(strategies)) {
    strategies <- strat
  } else if (!all(strategies %in% strat)) {
    wrong_strats <- setdiff(strategies, strat)
    errmsg <- paste0("the following are not in psa$strategies: ",
                     paste(wrong_strats, collapse = ","))
    stop(errmsg)
  }

  # define data for linear model
  dat <- data.frame(y, psa$parameters)

  # list to hold linear models
  lms <- NULL

  # analysis: either oneway or twoway
  if (analysis == "oneway") {
    # loop over parameters
    for (p in parms) {
      # loop over strategies
      for (s in strategies) {
        mod <- mm_run_reg(s, p, dat, pnames, type, poly.order)
        mod$parm_of_int <- p
        mod$strat <- s
        lms[[p]][[s]] <- mod
      }
    }
  }
  if (analysis == "twoway") {
    # loop over strategies
    for (s in strategies) {
      mod <- mm_run_reg(s, parms, dat, pnames, type, poly.order)
      # for accessing later in predict
      mod$parm_of_int <- parms
      mod$strat <- s
      lms[[s]] <- mod
    }
  }

  metamod <- list(outcome = outcome, mods = lms, wtp = wtp,
                  parms = parms, strategies = strategies,
                  psa = psa, analysis = analysis)
  # define class
  class(metamod) <- "metamodel"
  return(metamod)
}

#' this should have just one parm of int
#' when the analysis is one-way
#'
mm_run_reg <- function(dep, parms_of_int, dat, all_parms, type, poly.order) {
  # build formula
  ## dependent variable
  fbeg <- paste0(dep, " ~ ")

  ## parameters of interest
  fparm <- ""
  for (p in parms_of_int) {
    fparm <- paste0(fparm, "poly(", p, ",", poly.order, ", raw=TRUE) + ")
  }

  ## other parameters
  other_parms <- all_parms[-match(parms_of_int, all_parms)]
  fend <- paste(other_parms, collapse = " + ")

  ## combine
  f <- as.formula(paste0(fbeg, fparm, fend))

  # run metamodel
  metamodel <- lm(f, data = dat)
  metamodel$call <- call("lm", formula = f, data = quote(dat))
  return(metamodel)
}


#' Print metamodel
#'
#' @param x metamodel to print
#' @param ... further arguments to print
#' @export
print.metamodel <- function(x, ...) {
  wtp <- x$wtp
  cat("metamodel object", "\n",
      "-------------------------", "\n",
      "a list of the following objects: ",
      paste(names(x), collapse = ", "), "\n",
      "\n",
      "some details: ", "\n",
      "-------------------------", "\n",
      "analysis: this is a ", substr(x$analysis, 1, 3), "-way metamodel \n",
      "mods: a nested list of linear metamodels \n",
      "outcome: ", x$outcome, "\n",
      "WTP: ", ifelse(!is.null(wtp), wtp, "NA"), "\n",
      "strategies: ", paste(x$strategies, collapse = ", "), "\n",
      "parameters modeled: ", paste(x$parms, collapse = ", "), "\n",
      sep = "")
}

#' Summary of metamodel
#'
#' @param object metamodel to summarize
#' @param ... further arguments to summary
#' @export
summary.metamodel <- function(object, ...) {
  analysis <- object$analysis
  summary_df <- NULL
  if (analysis == "oneway") {
    for (p in object$parms) {
      for (s in object$strategies) {
        lm_summary <- summary(object$mods[[p]][[s]])
        r2 <- lm_summary$r.squared
        df_new_row <- data.frame("parm" = p, "strat" = s, "rsquared" = r2)
        summary_df <- rbind(summary_df, df_new_row)
      }
    }
  }
  if (analysis == "twoway") {
    parms <- object$parms
    for (s in object$strategies) {
      lm_summary <- summary(object$mods[[s]])
      r2 <- lm_summary$r.squared
      df_new_row <- data.frame("parm1" = parms[1], "parm2" = parms[2],
                               "strat" = s, "rsquared" = r2)
      summary_df <- rbind(summary_df, df_new_row)
    }
  }
  return(summary_df)
}

#' Predict from a metamodel
#'
#' @param object object with class "metamodel"
#' @param ranges A named list of the form c("parm" = c(0, 1), ...)
#' that gives the ranges for the parameter of interest. If NULL,
#' parameter values from the middle 95% of the PSA samples are used. The number of samples
#' from this range is determined by \code{nsamp}.
#' @param nsamp number of samples from ranges
#' @param ... further arguments to \code{predict} (not used)
#'
#' @importFrom stats quantile predict
#' @export
predict.metamodel <- function(object, ranges = NULL, nsamp = 100, ...) {
  # all parameters in psa
  psa_parms <- object$parms

  # get original psa parameter df
  psa_parmvals <- object$psa$parameters

  # set of linear models
  mods <- object$mods

  # strategies
  strats <- object$strategies

  # analysis type
  analysis <- object$analysis

  # data frame to be used in predict - mean values repeated
  # the values for the parameter of interest are replaced
  # in each pass through the loop
  if (analysis == "oneway") {
    pred_data_nrow <- nsamp
  }
  if (analysis == "twoway") {
    pred_data_nrow <- nsamp ^ 2
  }
  pdata <- data.frame(matrix(colMeans(psa_parmvals),
                             nrow = pred_data_nrow,
                             ncol = ncol(psa_parmvals),
                             byrow = T))

  # Name data frame's columns with parameters' names
  colnames(pdata) <- colnames(psa_parmvals)

  # these are parameters that are included in ranges
  if (is.null(ranges)) {
    q_parms <- psa_parms
  } else {
    q_parms <- names(ranges)
  }

  # predict outcomes from linear metamodels
  if (analysis == "oneway") {
    ## make list to hold outcome dfs
    outcome_dfs <- vector(mode = "list",
                          length = length(strats) * length(q_parms))
    counter <- 1
    for (p in q_parms) {
      # define evenly spaced samples from parameter range
      pranges_samp <- make_parm_seq(p, ranges, nsamp, psa_parmvals)

      # create new data from pranges_samp
      newdata <- data.frame(pranges_samp)

      # replace values for parameter of interest
      this_p_data <- pdata
      this_p_data[, p] <- newdata

      # predict values from linear model
      # for each strategy
      for (s in strats) {
        mod <- mods[[p]][[s]]
        outcome_dfs[[counter]] <- data.frame("parameter" = p, "strategy" = s,
                                             "param_val" = newdata,
                                             "outcome_val" = predict(mod, newdata = this_p_data),
                                             stringsAsFactors = FALSE)
        counter <- counter + 1
      }
    }
  }
  if (analysis == "twoway") {
    outcome_dfs <- vector(mode = "list",
                          length = length(strats))
    counter <- 1
    p1 <- psa_parms[1]
    p2 <- psa_parms[2]
    p1_samp <- make_parm_seq(p1, ranges, nsamp, psa_parmvals)
    p2_samp <- make_parm_seq(p2, ranges, nsamp, psa_parmvals)
    p1p2_data <- data.frame(expand.grid(p1_samp, p2_samp))
    pdata[, c(p1, p2)] <- p1p2_data

    for (s in strats) {
      mod <- mods[[s]]
      outcome <- predict(mod, newdata = pdata)
      outcome_df <- data.frame("p1" = pdata[, p1], "p2" = pdata[, p2],
                                           "strategy" = s, "outcome_val" = outcome,
                                           stringsAsFactors = FALSE)
      names(outcome_df)[1:2] <- c(p1, p2)
      outcome_dfs[[counter]] <- outcome_df
      counter <- counter + 1
    }
  }
  combined_df <- bind_rows(outcome_dfs)
  return(combined_df)
}


make_parm_seq <- function(p, ranges, nsamp, psa_parmvals) {
  p_range <- ranges[p]
  if (is.null(p_range)) {
    p_psa_vals <- psa_parmvals[, p]
    prange <- quantile(p_psa_vals, c(0.025, 0.975))
  }
  # define evenly spaced samples from parameter range
  seq(prange[1], prange[2], length.out = nsamp)
}
