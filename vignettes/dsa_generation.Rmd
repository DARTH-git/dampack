---
title: "Deterministic Sensitivity Analysis: Generation"
author: "Fernando Alarid-Escudero, Greg Knowlton, Eva Enns, and the DARTH Team"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Deterministic Sensitivity Analysis: Generation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5,
  fig.align = "center"
)
```

# Overview

`dampack` has the functionality to interface with a user-defined decision model in `R` to conduct a deterministic sensitivity analysis (DSA) on parameters of interest. DSA is a method for assessing how the results of a decision analytic model change as a parameter of interest in varied over a specified range of values. This includes both how model outcomes change (e.g. the expected cost of each strategy) as well as how the decision changes (e.g. which strategy is the most cost-effective) with the parameter of interest.

In a DSA, the model is run for each value of the parameter of interest over the specified range, while holding all other parameter values fixed. If one parameter is varied, this is called a one-way DSA. If two parameters are varied, it is called a two-way DSA. We typically do not vary more than two parameters at a time, as the output becomes difficult to visualize and interpret. A more comprehensive assessment of how model outptus depend on model parameters can be done through a probabilistic sensitivity analysis (PSA) (type `vignette("psa_generation", package = "dampack")` in the console after installing the `dampack` package to see a vignette describing how to use `dampack` for PSA).


## Decision Model Format

`dampack` includes functionality to generate DSA results for any user-defined decision analytic model that is written in `R`. The user-defined model must be written as a function takes in a list of all model parameter values as its first argument and outputs a data frame of modeled outcomes (e.g. costs, QALYs, etc.) for each strategy being evaluated by the model. The first column of the output data frame must be the strategy names (as strings) with any number of additional outcomes (costs, QALYs, infections averted, etc.) stored in subsequent columns. Thus, each row of the output data frame consists of the strategy's name followed by the corresponding outcome values for that strategy. The user-defined model function may have additional required or optional input arguments; values for these additional arguments will need to be passed to the function through the `dampack` DSA functions.

As an example, we define the function `run_sick_sicker_model` below, which is a four-state cohort state transition model (also known as a Markov model) that returns the total discounted costs and QALYs incured by a cohort progressing through a hypothetical disease known as the Sick-Sicker model. For a deeper discusison of state transition models and more complex variations of this state transition model, see Alarid-Escudero F, Krijkamp EM, Enns EA, Yang A, Hunink MGM, Pechlivanoglou P, Jalal H. Cohort state-transition models in R: A Tutorial. arXiv:200107824v1. 2020:1-31. 

```{r}
run_sick_sicker_model <- function(l_params_all, verbose = FALSE) {
  with(as.list(l_params_all), {
    # l_params_all must include:
    # -- disease progression parameters (annual): r_HD, p_S1S2, hr_S1D, hr_S2D, 
    # -- initial cohort distribution: v_s_init
    # -- vector of annual state utilities: v_state_utility = c(u_H, u_S1, u_S2, u_D)
    # -- vector of annual state costs: v_state_cost = c(c_H, c_S1, c_S2, c_D)
    # -- time horizon (in annual cycles): n_cyles
    # -- annual discount rate: r_disc
    
    ####### SET INTERNAL PARAMETERS #########################################
    
    # state names
    v_names_states <- c("H", "S1", "S2", "D")
    n_states <- length(v_names_states)
    
    # vector of discount weights
    v_dw  <- 1 / ((1 + r_disc) ^ (0:n_cycles))
    
    # state rewards
    v_state_cost <- c("H" = c_H, "S1" = c_S1, "S2" = c_S2, "D" = c_D)
    v_state_utility <- c("H" = u_H, "S1" = u_S1, "S2" = u_S2, "D" = u_D)
    
    # transition probability values
    r_S1D <- hr_S1D * r_HD 	 # rate of death in sick state
    r_S2D <- hr_S2D * r_HD   # rate of death in sicker state
    p_S1D <- 1 - exp(-r_S1D) # probability of dying when sick
    p_S2D <- 1 - exp(-r_S2D) # probability of dying when sicker
    p_HD  <- 1 - exp(-r_HD)   # probability of dying when healthy
    
    ## Initialize transition probability matrix 
    # all transitions to a non-death state are assumed to be conditional on survival 
    m_P <- matrix(0, 
                  nrow = n_states, ncol = n_states, 
                  dimnames = list(v_names_states, v_names_states)) # define row and column names
    ## Fill in matrix
    # From H
    m_P["H", "H"]   <- (1 - p_HD) * (1 - p_HS1)    
    m_P["H", "S1"]  <- (1 - p_HD) * p_HS1 
    m_P["H", "D"]   <- p_HD
    # From S1
    m_P["S1", "H"]  <- (1 - p_S1D) * p_S1H
    m_P["S1", "S1"] <- (1 - p_S1D) * (1 - (p_S1H + p_S1S2))
    m_P["S1", "S2"] <- (1 - p_S1D) * p_S1S2
    m_P["S1", "D"]  <- p_S1D
    # From S2
    m_P["S2", "S2"] <- 1 - p_S2D
    m_P["S2", "D"]  <- p_S2D
    # From D
    m_P["D", "D"]   <- 1
    
    # check that all transition matrix entries are between 0 and 1 
    if(!all(m_P <= 1 & m_P >= 0)){
      stop("This is not a valid transition matrix (entries are not between 0 and 1")
    } else
      # check transition matrix rows add up to 1
      if (!all.equal(as.numeric(rowSums(m_P)), rep(1, n_states))){
        stop("This is not a valid transition matrix (rows do not sum to 1)")
      }
    
    ####### INITIALIZATION #########################################
    # create the cohort trace
    m_Trace <- matrix(NA, nrow = n_cycles + 1 , 
                  ncol = n_states,
                  dimnames = list(0:n_cycles, v_names_states)) # create Markov trace
    
    # create vectors of costs and QALYs
    v_C <- v_Q <- numeric(length = n_cycles + 1)
    
    ############# PROCESS ###########################################
    
    m_Trace[1, ] <- v_s_init # initialize Markov trace
    v_C[1] <- 0 # no upfront costs
    v_Q[1] <- 0 # no upfront QALYs
    
    for (t in 1:n_cycles){ # throughout the number of cycles
      m_Trace[t + 1, ] <- m_Trace[t, ] %*% m_P # calculate trace for cycle (t + 1) based on cycle t
      
      v_C[t + 1] <- m_Trace[t + 1, ] %*% v_state_cost
      
      v_Q[t + 1] <- m_Trace[t + 1, ] %*% v_state_utility
      
    }
    
    #############  PRIMARY ECONOMIC OUTPUTS  #########################
    
    # Total discounted costs
    n_tot_cost <- t(v_C) %*% v_dw
    
    # Total discounted QALYs
    n_tot_qaly <- t(v_Q) %*% v_dw
    
    #############  OTHER OUTPUTS   ###################################
    
    # Total discounted life-years (sometimes used instead of QALYs)
    n_tot_ly <- t(m_Trace %*% c(1, 1, 1, 0)) %*% v_dw
    
    ####### RETURN OUTPUT  ###########################################
    out <- list(m_Trace = m_Trace,
                m_P = m_P,
                l_params_all,
                n_tot_cost = n_tot_cost,
                n_tot_qaly = n_tot_qaly,
                n_tot_ly = n_tot_ly)
    
    return(out)
  }
  )
}
```


`simulate_strategies` is a function that evaluates three strategies ("no treatment", "treatment A", and "treatment B") for a hypothetical disease. `run_sick_sicker_model` has as inputs `l_params_all`, which is the input parameter values list. It also has an additional optional argument `wtp` which allows the user to change the willingness-to-pay used in the model when calculating the net monetary benefit (NMB) model outcome. 

```{r}
simulate_strategies <- function(l_params_all, wtp = 100000){
    # l_params_all must include:
    # -- *** Model parameters ***
    # -- disease progression parameters (annual): r_HD, p_S1S2, hr_S1D, hr_S2D, 
    # -- initial cohort distribution: v_s_init
    # -- vector of annual state utilities: v_state_utility = c(u_H, u_S1, u_S2, u_D)
    # -- vector of annual state costs: v_state_cost = c(c_H, c_S1, c_S2, c_D)
    # -- time horizon (in annual cycles): n_cyles
    # -- annual discount rate: r_disc
    # -- *** Strategy specific parameters ***
    # -- treartment costs (applied to Sick and Sicker states): c_trtA, c_trtB
    # -- utility with treatment A (for Sick state only): u_trtA
    # -- hazard ratio of progression with treatment B: hr_S1S1_trtB
  
  with(as.list(l_params_all), {
    
    ####### SET INTERNAL PARAMETERS #########################################
    # Strategy names
    v_names_strat <- c("No Treatment", "Treatment A", "Treatment B")
    # Number of strategies
    n_strat <- length(v_names_strat)
    
    ## Treatment A
    # utility impacts
    u_S1_trtA <- u_trtA
    # include treatment costs
    c_S1_trtA <- c_S1 + c_trtA
    c_S2_trtA <- c_S2 + c_trtA
    
    ## Treatment B
    # progression impacts
    r_S1S2_trtB <- -log(1 - p_S1S2) * hr_S1S2_trtB 
    p_S1S2_trtB <- 1 - exp(-r_S1S2_trtB)
    # include treatment costs
    c_S1_trtB <- c_S1 + c_trtB
    c_S2_trtB <- c_S2 + c_trtB

    
    
    ####### INITIALIZATION #########################################
    # Create cost-effectiveness results data frame
    df_ce <- data.frame(Strategy = v_names_strat,
                        Cost = numeric(n_strat),
                        QALY = numeric(n_strat),
                        LY = numeric(n_strat),
                        stringsAsFactors = FALSE)
    
    
    ######### PROCESS ##############################################
    for (i in 1:n_strat){
      l_params_markov <- list(n_cycles = n_cycles, r_disc = r_disc, v_s_init = v_s_init,
                              c_H =  c_H, c_S1 = c_S2, c_S2 = c_S1, c_D = c_D,
                              u_H =  u_H, u_S1 = u_S2, u_S2 = u_S1, u_D = u_D,
                              r_HD = r_HD, hr_S1D = hr_S1D, hr_S2D = hr_S2D,
                              p_HS1 = p_HS1, p_S1S2 = p_S1S2)
      
      if (v_names_strat[i] == "Treatment A"){
        l_params_markov$u_S1 <- u_S1_trtA
        l_params_markov$c_S1 <- c_S1_trtA
        l_params_markov$c_S2 <- c_S2_trtA
        
      } else if(v_names_strat[i] == "Treatment B"){
        l_params_markov$p_S1S2 <- p_S1S2_trtB
        l_params_markov$c_S1   <- c_S1_trtB
        l_params_markov$c_S2   <- c_S2_trtB
      }

      l_result <- run_sick_sicker_model(l_params_markov)
      
      df_ce[i, c("Cost","QALY","LY")] <- c(l_result$n_tot_cost,
                                           l_result$n_tot_qaly,
                                           l_result$n_tot_ly)
      df_ce[i,"NMB"] <- l_result$n_tot_qaly * wtp - l_result$n_tot_cost
    }
    
    return(df_ce)
  })
}
```


```{r}
library(dampack)

## Set Markov model parameters
n_age_init <- 25                    # start age
n_age_max  <- 100                   # maximum age of follow up
n_cycles  <- n_age_max - n_age_init # time horizon (annual cycles)
r_disc <- 0.03                      # discount rate per cycle
v_s_init <- c(1, 0, 0, 0)           # initial cohort distribution (all Healthy)

# Transition probabilities (per annual cycle), hazard ratios and odds ratio
r_HD        <- 0.002  # constant rate of dying when Healthy (all-cause mortality)
hr_S1D      <- 3     # hazard ratio of death in Sick vs Healthy 
hr_S2D      <- 10    # hazard ratio of death in Sicker vs Healthy
p_HS1       <- 0.15   # probability of becoming Sick when Healthy conditional on surviving
p_S1H       <- 0.5    # probability of becoming Healthy when Sick conditional on surviving
p_S1S2      <- 0.105  # probability of becoming Sicker when Sick conditional on surviving

# Costs
c_H    <- 2000  # cost of one cycle in Healthy 
c_S1   <- 4000  # cost of one cycle in Sick 
c_S2   <- 15000 # cost of one cycle in Sicker 
c_D    <- 0     # cost of one cycle in Dead

# Utilities
u_H    <- 1     # utility when Healthy 
u_S1   <- 0.75  # utility when Sick 
u_S2   <- 0.5   # utility when Sicker
u_D    <- 0     # utility when Dead

# Strategy-specific inputs
c_trtA <- 12000 # cost of treatment A (applied to Sick and Sicker)
u_trtA <- 0.95  # utility while Sick under treatment A

c_trtB <- 13000     # cost of treatment B (applied to Sick and Sicker)
hr_S1S2_trtB <- 0.6 # hazard ratio of becoming Sicker when Sick under B under treatment B

# Create parameter list
l_params_all <- list(n_cycles = n_cycles, r_disc = r_disc, v_s_init = v_s_init,
                   c_H =  c_H, c_S1 = c_S2, c_S2 = c_S1, c_D = c_D,
                   u_H =  u_H, u_S1 = u_S2, u_S2 = u_S1, u_D = u_D,
                   r_HD = r_HD, hr_S1D = hr_S1D, hr_S2D = hr_S2D,
                   p_HS1 = p_HS1, p_S1S2 = p_S1S2,
                   c_trtA = c_trtA, u_trtA = u_trtA, 
                   c_trtB = c_trtB, hr_S1S2_trtB)

# Cost-effectiveness results 
df_ce <- simulate_strategies(l_params_all)
```

## Generating DSA results

A simple single-parameter DSA starts with choosing the model parameter to be investigated. Next, the modeler specifies a range for this parameter and the number of evenly spaced points along this range at which to evaluate model outcomes. The model is then run for each element of the vector of parameter values by setting the parameter of interest to the value, holding all other model parameters at their default base case values.

`dampack` uses the function `run_owsa_det` to execute a one-way DSA and the function `run_twsa_det` to execute a two-way DSA.

*** To be deleted / incorporated above ***

and the function `run_twsa_det` to execute a two-way DSA. `run_owsa_det` and `run_twsa_det` generate the vector of parameter values for which the user-defined model should be run and then also runs the model.  

containing a list of the parameters from the `params_basecase` argument. In the example model shown below, this list is named `l_params_all`, and the variables contained in this list are the only variables that are allowed to be varied through the `params_range` argument in the DSA. Optionally, additional function inputs for `FUN` can be supplied through the `...` argument of `run_owsa_det`/`run_twsa_det`, but these inputs are not allowed to vary in the sensitivity analysis. These additional inputs must be arguments of `FUN`, like `wtp` in the example of `calculate_ce_out()` below. `FUN` and its component functions are also able to incorporate variables stored in the global environment, such as `n_age_init` or `n_age_max` in the example.

The user-defined model function must return a data.frame where the first column contains a character vector of the strategy names, and the subsequent columns contain numeric vectors of all relevant model outcomes. Each row of the data.frame will consist of a strategy name followed by the corresponding outcome values for that strategy. These model outcomes must be calculated internally within `FUN`. The model outcomes are not limited to typical outcomes like cost or effectiveness and can be any numerical outcome that the user chooses to model.

`dampack` uses the function `run_owsa_det` to execute one-way DSAs and the function `run_twsa_det` to execute two-way DSAs. In order to perform a DSA in `dampack`, the user must input the code for the decision analytic model in a standardized format that is compatible with `run_owsa_det`, and `run_twsa_det`. This is the same format required for the `FUN` argument of `run_psa`.

*** END DELETIONS ***



## DSA Parameter Format

The `params_range` input tells `run_owsa_det` or `run_twsa_det` which parameters will be varied in the DSA and over what ranges. This input must be a data frame with 3 columns in the following order: "pars", "min", and "max". The number of samples from this range is determined by the input `nsamp`. The "pars" column is a character vector with the parameters of interest and must be a subset of the parameters from `params_basecase`.

when using `run_owsa_det`, supplying multiple parameters in `params_range` will instruct the function to execute a series of separate one-way deterministic sensitivity analyses and compile the results into a single `owsa` object for each requested `outcome`. When using `run_twsa_det`, exactly two parameters must be supplied in the `pars` column of the `params_range` data.frame argument.

```{r}
my_params_basecase <- list(p_HS1 = 0.15,
                           p_S1H = 0.5,
                           p_S1S2 = 0.105,
                           r_HD = 0.002, 
                           hr_S1D = 3, 
                           hr_S2D = 10,
                           hr_S1S2_trtB = 0.6,
                           c_H = 2000,
                           c_S1 = 4000,
                           c_S2 = 15000, 
                           c_D = 0,
                           c_trtA = 12000,
                           c_trtB = 13000,
                           u_H = 1,
                           u_S1 = 0.75,
                           u_S2 = 0.5,
                           u_D = 0,
                           u_trtA = 0.95,
                           n_cycles = 75,
                           v_s_init = c(1, 0, 0, 0),
                           r_disc = 0.03)

my_params_range <- data.frame(pars = c("u_trtA", "c_trtA", "hr_S1S2_trtB", "r_HD"),
                              min = c(0.9, 9000, 0.3, 0.001),
                              max = c(1,   24000, 0.9, 0.003))

```

## One-way Deterministic Sensitivity Analysis

In `run_owsa_det`, the user is free to specify any number of outcomes that are defined in the user-defined function (the `FUN` argument, which is `calculate_ce_out` in this example). If more than one outcome is provided, `run_owsa_det` will return a list containing one `owsa` object for each outcome. If the decision model in `FUN` is computationally slow and `nsamp` is large, `run_owsa_det` could take an extremely long time to run. Under these circumstances, it is recommended that you set the `progress` argument to `TRUE` in order to print a progress bar in the console while the function is running.

Each `owsa` object returned by `run_owsa_det` is a `data.frame` with four columns, `parameter`, `strategy`, `param_val`, and `outcome_val`. Each row's value in the `parameter` column denotes which parameter was swapped into  the basecase parameters, and `param_val` indicates which particular value of this parameter was used in that iteration of the decision model. The `outcome_val`s corresponding to each combination of `strategy`, `parameter`, and `param_val` are provided in long format within the `owsa` object.

To access a single `owsa` object associated with the `"NMB"` outcome within the returned list, we can simply write `l_owsa_det$owsa_NMB`.

```{r}
l_owsa_det <- run_owsa_det(params_range = my_params_range,
                         params_basecase = my_params_basecase,
                         nsamp = 100,
                         FUN = simulate_strategies,
                         outcomes = c("Cost", "QALY", "LY", "NMB"),
                         strategies = c("No_Treatment", "Treatment_A", "Treatment_B"),
                         progress = FALSE)

my_owsa_NMB <- l_owsa_det$owsa_NMB

owsa_opt_strat(my_owsa_NMB)

```

## Two-way Deterministic Sensitivty Analysis

A two-way sensitivity analysis is used to assess how model outcomes vary over pre-specified ranges of two model parameters jointly. The general format of the function arguments for `dampack`'s two-way DSA function, `run_twsa_det`, are the same as those for `run_owsa_det`. In `run_twsa_det`, equally spaced sequences of length `nsamp` are created for the two parameters based on the inputs provided in the `params_range` argument. These two sequences of parameter values define an `nsamp` by `nsamp` grid over which `FUN` is applied to produce outcomes for every combination of the two parameters.

If more than one outcome is provided, `run_twsa_det` will return a list containing one `twsa` object for each outcome. To access a single `twsa` object associated with the `"NMB"` outcome within the returned list, we write `l_twsa_det$twsa_NMB`. Each `twsa` object is a long form `data.frame` that reports the outcome value for each each strategy at every parameter combination. The first two columns are named according to the two parameters specified in `params_range`. 

```{r}
l_twsa_det <- run_twsa_det(params_range = my_params_range[c(3,4),],
                         params_basecase = my_params_basecase,
                         nsamp = 50,
                         FUN = simulate_strategies,
                         outcomes = c("Cost","QALY","NMB"),
                         strategies = c("No_Treatment", "Treatment_A", "Treatment_B"),
                         progress = FALSE)

my_twsa_NMB <- l_twsa_det$twsa_NMB

plot(my_twsa_NMB)

```
